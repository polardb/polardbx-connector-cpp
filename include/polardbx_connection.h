#ifndef _POLARDBX_CONNECTION_H_
#define _POLARDBX_CONNECTION_H_

#include "jdbc/cppconn/connection.h"
#include "ha_manager.h"
#include <jdbc/mysql_driver.h>
#include <memory>

namespace sql
{
namespace polardbx
{

class CPPCONN_PUBLIC_FUNC PolarDBX_Connection : public sql::Connection
{

public:
  PolarDBX_Connection(Driver * _driver,
          const sql::SQLString& hostName,
          const sql::SQLString& userName,
          const sql::SQLString& password);

  PolarDBX_Connection(Driver * _driver,
          std::map< sql::SQLString, sql::ConnectPropertyVal > & options);

  virtual ~PolarDBX_Connection();

  void clearWarnings();

  void close();

  void commit();

  sql::Statement * createStatement();

  sql::SQLString escapeString(const sql::SQLString &);

  bool getAutoCommit();

  sql::SQLString getCatalog();

  Driver * getDriver();

  sql::SQLString getSchema();

  sql::SQLString getClientInfo();

  void getClientOption(const sql::SQLString & optionName, void * optionValue);

  sql::SQLString getClientOption(const sql::SQLString & optionName);

  sql::DatabaseMetaData * getMetaData();

  enum_transaction_isolation getTransactionIsolation();

  const SQLWarning * getWarnings();

  bool isClosed();

  bool isReadOnly();

  bool isValid();

  bool reconnect();

  sql::SQLString nativeSQL(const sql::SQLString& sql);

  sql::PreparedStatement * prepareStatement(const sql::SQLString& sql);

  sql::PreparedStatement * prepareStatement(const sql::SQLString& sql, int autoGeneratedKeys);

  sql::PreparedStatement * prepareStatement(const sql::SQLString& sql, int columnIndexes[]);

  sql::PreparedStatement * prepareStatement(const sql::SQLString& sql, int resultSetType, int resultSetConcurrency);

  sql::PreparedStatement * prepareStatement(const sql::SQLString& sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability);

  sql::PreparedStatement * prepareStatement(const sql::SQLString& sql, sql::SQLString columnNames[]);

  void releaseSavepoint(Savepoint * savepoint);

  void rollback();

  void rollback(Savepoint * savepoint);

  void setAutoCommit(bool autoCommit);

  void setCatalog(const sql::SQLString& catalog);

  void setSchema(const sql::SQLString& catalog);

  sql::Connection * setClientOption(const sql::SQLString & optionName, const void * optionValue);

  sql::Connection * setClientOption(const sql::SQLString & optionName, const sql::SQLString & optionValue);

  void setHoldability(int holdability);

  void setReadOnly(bool readOnly);

  sql::Savepoint * setSavepoint();

  sql::Savepoint * setSavepoint(const sql::SQLString& name);

  void setTransactionIsolation(enum_transaction_isolation level);

  virtual sql::SQLString getSessionVariable(const sql::SQLString & varname);

  virtual void setSessionVariable(const sql::SQLString & varname, const sql::SQLString & value);

  virtual void setSessionVariable(const sql::SQLString & varname, unsigned int value);

  virtual sql::SQLString getLastStatementInfo();

  // debug
  std::string getConnectionAddr();

private:
  Driver * driver;
  sql::Connection * real_conn;
  std::shared_ptr<HaManager> ha_manager_;
  std::string conn_addr_;

  /* Prevent use of these */
  PolarDBX_Connection(const PolarDBX_Connection &);
  void operator=(PolarDBX_Connection &);
  void recordJDBCURL(const std::string & jdbc_url, sql::Connection * conn);
  void enableFollowerRead(int followerReadState, sql::Connection * conn);
};

} /* namespace polardbx */
} /* namespace sql */

#endif // _POLARDBX_CONNECTION_H_

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * End:
 * vim600: noet sw=4 ts=4 fdm=marker
 * vim<600: noet sw=4 ts=4
 */
